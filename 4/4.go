package main

import (
	"fmt"
	"strings"
)

//Написать функцию поиска всех множеств анаграмм по словарю.
//
//
//Например:
//'пятак', 'пятка' и 'тяпка' - принадлежат одному множеству,
//'листок', 'слиток' и 'столик' - другому.
//
//
//Требования:
//Входные данные для функции: ссылка на массив, каждый элемент которого - слово на русском языке в кодировке utf8
//Выходные данные: ссылка на мапу множеств анаграмм
//Ключ - первое встретившееся в словаре слово из множества. Значение - ссылка на массив, каждый элемент которого,
//слово из множества.
//Массив должен быть отсортирован по возрастанию.
//Множества из одного элемента не должны попасть в результат.
//Все слова должны быть приведены к нижнему регистру.
//В результате каждое слово должно встречаться только один раз.

func main() {
	var numberOfWords int
	fmt.Println("введите количество слов")
	fmt.Scan(&numberOfWords)
	var word string
	words := make([]string, 0, numberOfWords)
	for i := 0; i < numberOfWords; i++ {
		fmt.Scan(&word)
		words = append(words, word)
	}
	fmt.Println(anagrams(words))
}
func anagrams(words []string) map[string][]string {
	//сразу все приводим к нижнему регистру
	for i := range words {
		words[i] = strings.ToLower(words[i])
	}
	result := make(map[string][]string, len(words))
out:
	for _, j := range words {
		//если слово является анаграммой, то добавляем его к словарю
		if ok, key := checkIfAnagram(result, j); ok {
			//если у ключа появляется анаграмма, то аллоцируем память под слайс с запасом, чтобы избежать эвакуации
			if result[key] == nil {
				result[key] = make([]string, 0, len(words))
			}
			//добавляем значение, если его нет
			for _, word := range result[key] {
				if word == j {
					continue out
				}
			}
			result[key] = append(result[key], j)
		} else { //Если анаграммой не является, то добавляем его в качестве ключа. Ставим nil чтобы без необходимости не создавать слайс
			result[j] = nil
		}
	}
	//чистим мапу от ниловых значений
	for i, j := range result {
		if j == nil {
			delete(result, i)
		}
	}
	return result
}

func checkIfAnagram(m map[string][]string, word string) (bool, string) {
	//пробегаемся по ключам в мапе
	//называем внешний цикл, чтобы завершать его

out:
	for i := range m {
		//если длина ключа не совпадает с длиной слова, то сразу начинаем следующую итерацию
		if len(i) != len(word) {
			continue
		}
		//создаем мапу для проверки
		checker := make(map[rune]int, len(i))
		//пробегаемся по ключу в мапе
		for _, j := range []rune(i) {
			//заносим в checker все руны и сколько раз они встречаются
			//если значение уже есть в мапе, то увеличиваем его на 1
			if _, ok := checker[j]; ok {
				checker[j]++
			}
			//если значения не было, то добавляем его
			if _, ok := checker[j]; !ok {
				checker[j] = 1
			}
		}
		//сравниваем с переданным словом
		for _, q := range []rune(word) {
			//если значения нет, то сразу переходим дальше
			if _, ok := checker[q]; !ok {
				//переходим к следующей итерации внешнего циклы
				continue out
			}
			//если значение есть
			if value, ok := checker[q]; ok {
				//если буква в слове встречается больше раз чем в ключе, то переходим к следующей итерации
				if value == 0 {
					//переходим к следующей итерации внешнего циклы
					continue out
				}
				//если нет, то убавляем количество появления буквы в чекере
				if value > 0 {
					checker[q]--
				}
			}
		}
		//если слово подошло под анаграмму, то сразу возвращаем результат
		return true, i
	}
	//если ни одно слово не является анаграммой, то возвращаем false
	return false, ""
}
